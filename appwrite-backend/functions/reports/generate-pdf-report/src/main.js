import { Client, Databases, Storage, Query, InputFile } from 'node-appwrite';
import PDFDocument from 'pdfkit';
import moment from 'moment';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Environment variables
const APPWRITE_ENDPOINT = process.env.APPWRITE_ENDPOINT || 'https://cloud.appwrite.io/v1';
const APPWRITE_PROJECT_ID = process.env.APPWRITE_PROJECT_ID;
const APPWRITE_API_KEY = process.env.APPWRITE_API_KEY;
const APPWRITE_DATABASE_ID = process.env.APPWRITE_DATABASE_ID;
const APPWRITE_STORAGE_BUCKET_ID = process.env.APPWRITE_STORAGE_BUCKET_ID;
const REPORT_LOGO_URL = process.env.REPORT_LOGO_URL || 'https://via.placeholder.com/150x50?text=ImmuneMe';
const REPORT_FOOTER_TEXT = process.env.REPORT_FOOTER_TEXT || 'Generated by ImmuneMe System';
const REPORT_PRIMARY_COLOR = process.env.REPORT_PRIMARY_COLOR || '#2563eb';
const REPORT_SECONDARY_COLOR = process.env.REPORT_SECONDARY_COLOR || '#64748b';

// Initialize Appwrite clients
const client = new Client()
  .setEndpoint(APPWRITE_ENDPOINT)
  .setProject(APPWRITE_PROJECT_ID)
  .setKey(APPWRITE_API_KEY);

const databases = new Databases(client);
const storage = new Storage(client);

// Report type configurations
const REPORT_CONFIGS = {
  immunization_coverage: {
    title: 'Immunization Coverage Report',
    description: 'Comprehensive analysis of immunization coverage across facilities',
    collection: 'immunization_records',
    fields: ['vaccine_name', 'facility_id', 'patient_id', 'administered_date', 'status']
  },
  facility_performance: {
    title: 'Facility Performance Report',
    description: 'Performance metrics and statistics for healthcare facilities',
    collection: 'facilities',
    fields: ['name', 'location', 'total_patients', 'total_immunizations', 'performance_score']
  },
  due_immunizations: {
    title: 'Due Immunizations Report',
    description: 'List of patients with upcoming or overdue immunizations',
    collection: 'vaccine_schedules',
    fields: ['patient_id', 'vaccine_name', 'due_date', 'status', 'facility_id']
  }
};

// PDF Generation class
class PDFReportGenerator {
  constructor(reportType, filters = {}) {
    this.reportType = reportType;
    this.filters = filters;
    this.config = REPORT_CONFIGS[reportType];
    this.doc = new PDFDocument({ size: 'A4', margin: 50 });
    this.pageHeight = 842;
    this.pageWidth = 595;
    this.margin = 50;
  }

  async generateReport() {
    try {
      console.log(`Starting PDF generation for ${this.reportType}`);
      
      // Fetch data based on report type
      const data = await this.fetchReportData();
      
      // Create temporary file path
      const timestamp = moment().format('YYYYMMDDHHmmss');
      const filename = `${this.reportType}_${timestamp}.pdf`;
      const filepath = path.join('/tmp', filename);
      
      // Create write stream
      const stream = fs.createWriteStream(filepath);
      this.doc.pipe(stream);
      
      // Generate PDF content
      await this.generateHeader();
      await this.generateSummary(data);
      await this.generateContent(data);
      await this.generateFooter();
      
      // Finalize PDF
      this.doc.end();
      
      // Wait for file to be written
      await new Promise((resolve, reject) => {
        stream.on('finish', resolve);
        stream.on('error', reject);
      });
      
      // Upload to Appwrite Storage
      const fileId = await this.uploadToStorage(filepath, filename);
      
      // Generate download URL
      const downloadUrl = await this.generateDownloadUrl(fileId);
      
      // Clean up temporary file
      fs.unlinkSync(filepath);
      
      return {
        success: true,
        fileId,
        downloadUrl,
        filename,
        reportType: this.reportType,
        generatedAt: new Date().toISOString()
      };
      
    } catch (error) {
      console.error('Error generating PDF report:', error);
      throw error;
    }
  }

  async fetchReportData() {
    try {
      let queries = [];
      
      // Apply date filters if provided
      if (this.filters.startDate) {
        queries.push(Query.greaterThanEqual('created_at', this.filters.startDate));
      }
      if (this.filters.endDate) {
        queries.push(Query.lessThanEqual('created_at', this.filters.endDate));
      }
      if (this.filters.facilityId) {
        queries.push(Query.equal('facility_id', this.filters.facilityId));
      }
      
      // Fetch data based on report type
      let data = [];
      
      switch (this.reportType) {
        case 'immunization_coverage':
          data = await this.fetchImmunizationCoverageData(queries);
          break;
        case 'facility_performance':
          data = await this.fetchFacilityPerformanceData(queries);
          break;
        case 'due_immunizations':
          data = await this.fetchDueImmunizationsData(queries);
          break;
        default:
          throw new Error(`Unsupported report type: ${this.reportType}`);
      }
      
      return data;
      
    } catch (error) {
      console.error('Error fetching report data:', error);
      throw error;
    }
  }

  async fetchImmunizationCoverageData(queries) {
    try {
      const response = await databases.listDocuments(
        APPWRITE_DATABASE_ID,
        'immunization_records',
        queries
      );
      
      // Group by vaccine and calculate coverage
      const coverageData = {};
      response.documents.forEach(record => {
        const vaccine = record.vaccine_name;
        if (!coverageData[vaccine]) {
          coverageData[vaccine] = {
            name: vaccine,
            total: 0,
            completed: 0,
            pending: 0,
            percentage: 0
          };
        }
        
        coverageData[vaccine].total++;
        if (record.status === 'completed') {
          coverageData[vaccine].completed++;
        } else {
          coverageData[vaccine].pending++;
        }
      });
      
      // Calculate percentages
      Object.values(coverageData).forEach(vaccine => {
        vaccine.percentage = vaccine.total > 0 ? 
          Math.round((vaccine.completed / vaccine.total) * 100) : 0;
      });
      
      return Object.values(coverageData);
      
    } catch (error) {
      console.error('Error fetching immunization coverage data:', error);
      throw error;
    }
  }

  async fetchFacilityPerformanceData(queries) {
    try {
      const facilitiesResponse = await databases.listDocuments(
        APPWRITE_DATABASE_ID,
        'facilities',
        []
      );
      
      const performanceData = [];
      
      for (const facility of facilitiesResponse.documents) {
        // Count patients for this facility
        const patientsResponse = await databases.listDocuments(
          APPWRITE_DATABASE_ID,
          'patients',
          [Query.equal('facility_id', facility.$id)]
        );
        
        // Count immunizations for this facility
        const immunizationsResponse = await databases.listDocuments(
          APPWRITE_DATABASE_ID,
          'immunization_records',
          [Query.equal('facility_id', facility.$id)]
        );
        
        performanceData.push({
          id: facility.$id,
          name: facility.name,
          location: facility.location || 'N/A',
          totalPatients: patientsResponse.total,
          totalImmunizations: immunizationsResponse.total,
          performanceScore: Math.round(
            (immunizationsResponse.total / Math.max(patientsResponse.total, 1)) * 100
          )
        });
      }
      
      return performanceData;
      
    } catch (error) {
      console.error('Error fetching facility performance data:', error);
      throw error;
    }
  }

  async fetchDueImmunizationsData(queries) {
    try {
      // Add status filter for due immunizations
      queries.push(Query.equal('status', 'due'));
      
      const response = await databases.listDocuments(
        APPWRITE_DATABASE_ID,
        'vaccine_schedules',
        queries
      );
      
      const dueData = [];
      
      for (const schedule of response.documents) {
        // Fetch patient details
        const patientResponse = await databases.getDocument(
          APPWRITE_DATABASE_ID,
          'patients',
          schedule.patient_id
        );
        
        // Fetch facility details
        const facilityResponse = await databases.getDocument(
          APPWRITE_DATABASE_ID,
          'facilities',
          schedule.facility_id
        );
        
        dueData.push({
          id: schedule.$id,
          patientName: `${patientResponse.first_name} ${patientResponse.last_name}`,
          patientId: patientResponse.$id,
          vaccineName: schedule.vaccine_name,
          dueDate: schedule.due_date,
          facilityName: facilityResponse.name,
          daysOverdue: moment().diff(moment(schedule.due_date), 'days')
        });
      }
      
      return dueData;
      
    } catch (error) {
      console.error('Error fetching due immunizations data:', error);
      throw error;
    }
  }

  async generateHeader() {
    // Header background
    this.doc.rect(0, 0, this.pageWidth, 100)
      .fill(REPORT_PRIMARY_COLOR);
    
    // Logo placeholder
    this.doc.fillColor('white')
      .fontSize(20)
      .text('IMMUNEME', this.margin, 40);
    
    // Report title
    this.doc.fontSize(16)
      .text(this.config.title, this.margin + 150, 40);
    
    // Report date
    this.doc.fontSize(10)
      .text(`Generated: ${moment().format('MMMM Do YYYY, h:mm:ss a')}`, this.margin + 150, 65);
    
    // Add spacing after header
    this.doc.moveDown(3);
  }

  async generateSummary(data) {
    this.doc.fillColor('black')
      .fontSize(14)
      .text('Executive Summary', this.margin, 120)
      .moveDown();
    
    this.doc.fontSize(10)
      .text(this.config.description, this.margin)
      .moveDown();
    
    // Summary statistics
    let summaryText = '';
    switch (this.reportType) {
      case 'immunization_coverage':
        summaryText = `Total vaccines analyzed: ${data.length}`;
        break;
      case 'facility_performance':
        summaryText = `Total facilities: ${data.length}`;
        break;
      case 'due_immunizations':
        summaryText = `Total due immunizations: ${data.length}`;
        break;
    }
    
    this.doc.text(summaryText, this.margin)
      .moveDown(2);
  }

  async generateContent(data) {
    switch (this.reportType) {
      case 'immunization_coverage':
        await this.generateImmunizationCoverageContent(data);
        break;
      case 'facility_performance':
        await this.generateFacilityPerformanceContent(data);
        break;
      case 'due_immunizations':
        await this.generateDueImmunizationsContent(data);
        break;
    }
  }

  async generateImmunizationCoverageContent(data) {
    this.doc.fontSize(12)
      .text('Vaccine Coverage Analysis', this.margin)
      .moveDown();
    
    // Table headers
    const tableTop = this.doc.y;
    const headers = ['Vaccine', 'Total', 'Completed', 'Pending', 'Coverage %'];
    const columnWidths = [150, 80, 80, 80, 80];
    let currentX = this.margin;
    
    // Draw headers
    headers.forEach((header, i) => {
      this.doc.rect(currentX, tableTop, columnWidths[i], 20)
        .fill(REPORT_SECONDARY_COLOR);
      this.doc.fillColor('white')
        .text(header, currentX + 5, tableTop + 5);
      currentX += columnWidths[i];
    });
    
    // Draw data rows
    let currentY = tableTop + 20;
    data.forEach((item, index) => {
      currentX = this.margin;
      const rowData = [
        item.name,
        item.total.toString(),
        item.completed.toString(),
        item.pending.toString(),
        `${item.percentage}%`
      ];
      
      rowData.forEach((cell, i) => {
        this.doc.rect(currentX, currentY, columnWidths[i], 20)
          .fill(index % 2 === 0 ? '#f8fafc' : '#ffffff');
        this.doc.fillColor('black')
          .text(cell, currentX + 5, currentY + 5);
        currentX += columnWidths[i];
      });
      
      currentY += 20;
      
      // Check for page break
      if (currentY > this.pageHeight - 100) {
        this.doc.addPage();
        currentY = this.margin;
      }
    });
    
    this.doc.y = currentY + 20;
  }

  async generateFacilityPerformanceContent(data) {
    this.doc.fontSize(12)
      .text('Facility Performance Metrics', this.margin)
      .moveDown();
    
    // Sort by performance score
    data.sort((a, b) => b.performanceScore - a.performanceScore);
    
    // Table headers
    const tableTop = this.doc.y;
    const headers = ['Facility', 'Location', 'Patients', 'Immunizations', 'Score %'];
    const columnWidths = [120, 100, 70, 90, 70];
    let currentX = this.margin;
    
    // Draw headers
    headers.forEach((header, i) => {
      this.doc.rect(currentX, tableTop, columnWidths[i], 20)
        .fill(REPORT_SECONDARY_COLOR);
      this.doc.fillColor('white')
        .text(header, currentX + 5, tableTop + 5);
      currentX += columnWidths[i];
    });
    
    // Draw data rows
    let currentY = tableTop + 20;
    data.forEach((item, index) => {
      currentX = this.margin;
      const rowData = [
        item.name,
        item.location,
        item.totalPatients.toString(),
        item.totalImmunizations.toString(),
        `${item.performanceScore}%`
      ];
      
      rowData.forEach((cell, i) => {
        this.doc.rect(currentX, currentY, columnWidths[i], 20)
          .fill(index % 2 === 0 ? '#f8fafc' : '#ffffff');
        this.doc.fillColor('black')
          .text(cell, currentX + 5, currentY + 5);
        currentX += columnWidths[i];
      });
      
      currentY += 20;
      
      // Check for page break
      if (currentY > this.pageHeight - 100) {
        this.doc.addPage();
        currentY = this.margin;
      }
    });
    
    this.doc.y = currentY + 20;
  }

  async generateDueImmunizationsContent(data) {
    this.doc.fontSize(12)
      .text('Due Immunizations List', this.margin)
      .moveDown();
    
    // Sort by due date
    data.sort((a, b) => moment(a.dueDate).valueOf() - moment(b.dueDate).valueOf());
    
    // Table headers
    const tableTop = this.doc.y;
    const headers = ['Patient', 'Vaccine', 'Due Date', 'Facility', 'Days Overdue'];
    const columnWidths = [100, 80, 80, 100, 80];
    let currentX = this.margin;
    
    // Draw headers
    headers.forEach((header, i) => {
      this.doc.rect(currentX, tableTop, columnWidths[i], 20)
        .fill(REPORT_SECONDARY_COLOR);
      this.doc.fillColor('white')
        .text(header, currentX + 5, tableTop + 5);
      currentX += columnWidths[i];
    });
    
    // Draw data rows
    let currentY = tableTop + 20;
    data.forEach((item, index) => {
      currentX = this.margin;
      const rowData = [
        item.patientName,
        item.vaccineName,
        moment(item.dueDate).format('MMM DD, YYYY'),
        item.facilityName,
        item.daysOverdue > 0 ? `${item.daysOverdue}` : 'Due'
      ];
      
      rowData.forEach((cell, i) => {
        this.doc.rect(currentX, currentY, columnWidths[i], 20)
          .fill(index % 2 === 0 ? '#f8fafc' : '#ffffff');
        this.doc.fillColor('black')
          .text(cell, currentX + 5, currentY + 5);
        currentX += columnWidths[i];
      });
      
      currentY += 20;
      
      // Check for page break
      if (currentY > this.pageHeight - 100) {
        this.doc.addPage();
        currentY = this.margin;
      }
    });
    
    this.doc.y = currentY + 20;
  }

  async generateFooter() {
    const footerY = this.pageHeight - 50;
    
    // Footer line
    this.doc.moveTo(this.margin, footerY - 10)
      .lineTo(this.pageWidth - this.margin, footerY - 10)
      .strokeColor(REPORT_SECONDARY_COLOR)
      .stroke();
    
    // Footer text
    this.doc.fillColor(REPORT_SECONDARY_COLOR)
      .fontSize(8)
      .text(REPORT_FOOTER_TEXT, this.margin, footerY);
    
    // Page number
    this.doc.text(`Page ${this.doc.pageCount}`, this.pageWidth - 100, footerY);
  }

  async uploadToStorage(filepath, filename) {
    try {
      const fileBuffer = fs.readFileSync(filepath);
      
      const file = await storage.createFile(
        APPWRITE_STORAGE_BUCKET_ID,
        'unique()',
        InputFile.fromBuffer(fileBuffer, filename)
      );
      
      return file.$id;
      
    } catch (error) {
      console.error('Error uploading to storage:', error);
      throw error;
    }
  }

  async generateDownloadUrl(fileId) {
    try {
      const url = storage.getFileDownload(
        APPWRITE_STORAGE_BUCKET_ID,
        fileId
      );
      
      return url;
      
    } catch (error) {
      console.error('Error generating download URL:', error);
      throw error;
    }
  }
}

// Main function handler
export default async ({ req, res, log, error }) => {
  try {
    // Validate request
    if (!req.body || !req.body.reportType) {
      return res.json({
        success: false,
        error: 'Missing required parameter: reportType'
      }, 400);
    }

    const { reportType, filters = {} } = req.body;

    // Validate report type
    if (!REPORT_CONFIGS[reportType]) {
      return res.json({
        success: false,
        error: `Invalid report type: ${reportType}. Valid types: ${Object.keys(REPORT_CONFIGS).join(', ')}`
      }, 400);
    }

    // Generate PDF report
    const generator = new PDFReportGenerator(reportType, filters);
    const result = await generator.generateReport();

    return res.json(result, 200);

  } catch (err) {
    error('Error in generate-pdf-report function:', err);
    return res.json({
      success: false,
      error: err.message || 'Internal server error'
    }, 500);
  }
};

// For local testing
if (process.env.NODE_ENV === 'development') {
  const mockReq = {
    body: {
      reportType: 'immunization_coverage',
      filters: {
        startDate: '2024-01-01',
        endDate: '2024-12-31'
      }
    }
  };
  
  const mockRes = {
    json: (data, status) => {
      console.log('Response:', data);
      console.log('Status:', status);
    }
  };
  
  const mockLog = console.log;
  const mockError = console.error;
  
  // Run local test
  (async () => {
    const handler = (await import('./main.js')).default;
    await handler({ req: mockReq, res: mockRes, log: mockLog, error: mockError });
  })();
}